<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c5{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c14{font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c11{font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{text-decoration-skip-ink:none;font-size:12pt;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c15{background-color:#ffffff;max-width:540pt;margin: auto;padding:36pt 36pt 36pt 36pt}.c4{color:inherit;text-decoration:inherit}.c13{background-color:#ffff00}.c3{color:#2fcc63}.c9{color:#b8b8b8}.c10{font-size:12pt}.c8{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c15"><p class="c6"><span class="c1">Development Log #1</span></p><p class="c6"><span class="c1">Tank Trax Clone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c6"><span class="c1">07 / 2019</span></p><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span class="c0"><a class="c4" href="#id.fxkkr6ffxg1w">Game Breakdown</a></span></p><p class="c7"><span class="c0"><a class="c4" href="#id.flj520tzh8mu">Terrain Generation</a></span></p><p class="c7"><span class="c0"><a class="c4" href="#id.uq3gaokhmg21">Startup </a></span></p><p class="c7"><span class="c0"><a class="c4" href="#id.5iumakmjt8yx">Enemy AI </a></span></p><p class="c7"><span class="c0"><a class="c4" href="#id.8bc87fbtrk9h">Terrain Deformation</a></span></p><p class="c7"><span class="c0"><a class="c4" href="#id.dtb1ml45pyfp">End</a></span></p><p class="c2"><span class="c1"></span></p><a id="id.fxkkr6ffxg1w"></a><h2 class="c5" id="h.vnht2suej8kr"><span class="c12">Game Breakdown</span></h2><hr><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Hey guys, so the game I took the most inspiration from, was this retro game for the Sinclair ZX Spectrum called Tank Trax. </span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 450.50px; height: 337.15px;"><img alt="" src="images/image9.png" style="width: 450.50px; height: 337.15px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Pretty much there is a random terrain generated for each level. two tanks are placed randomly within the level. And they take turns aiming at each other and firing. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The game I made, is a bit different. Instead of each tank taking turns, it&rsquo;s all in realtime, and each shoot then starts a cooldown period before a shot can be taken.</span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 353.33px;"><img alt="" src="images/image20.png" style="width: 624.00px; height: 353.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The main controls for the game is the mouse, the mouse controls the angle which your turret will be aiming. Scrolling the mouse wheel controls the power of the next shot. And left clicking fires the bullet.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">I wanted to create a challenging AI, that would not kill you in the first 2 seconds. This was a bit tricky and required lots of testing to get it to a point where I felt it was acceptable.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c10">For this project I created a few of the systems in javascript. I used an external js library for RNG (Random number generation). </span><span class="c0"><a class="c4" href="https://www.google.com/url?q=https://chancejs.com/&amp;sa=D&amp;ust=1564436451804000">Chance.js</a></span><span class="c10">&nbsp;is based on the </span><span class="c0"><a class="c4" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Mersenne_Twister&amp;sa=D&amp;ust=1564436451804000">Mersenne Twister Algorithm</a></span><span class="c1">, which is used to generate pseudo random numbers. This library was used in the terrain generation and in picking the tanks positions.</span></p><a id="id.flj520tzh8mu"></a><h2 class="c5" id="h.dmga3n1i4sgv"><span class="c12">Terrain Generation</span></h2><hr><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">I knew I wanted to accomplish a similar terrain generation. I decided to use 8x8 Tiles to represent the map. To encapsulate all the functionality of generating the terrain and dealing with the tilemap I created TerrainGen.js class</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 730.50px; height: 572.15px;"><img alt="" src="images/image24.png" style="width: 730.50px; height: 572.15px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">This class was in charge of managing the map data structure, rendering the map to a tileMap in the layout (partial), calculating the collision zone to deform the map, managing the random number generator, and choosing random position on the map. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The Algorithm I used to create the terrain is pretty simple. We will go over it in detail below. </span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 667.50px; height: 471.45px;"><img alt="" src="images/image2.png" style="width: 667.50px; height: 471.45px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">We picked the height we want to start generating the terrain. We try to avoid picking a Y close to the top and bottom.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 677.50px; height: 68.40px;"><img alt="" src="images/image6.png" style="width: 677.50px; height: 68.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Then we iterate through every X value in the tile map. At every X, we fill that tile on the map with a solid block. </span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 540.19px; height: 157.50px;"><img alt="" src="images/image5.png" style="width: 540.19px; height: 157.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7 c8"><span class="c1"></span></p><p class="c7 c8"><span class="c1"></span></p><p class="c7"><span class="c1">Then we fill every tile under that tile with a solid block as well.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 451.00px; height: 101.00px;"><img alt="" src="images/image31.png" style="width: 451.00px; height: 101.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">After we have filled in the column, We then do one of three things, we leave the Y the same, we increase the Y by 1, or decrease the Y by 1. In this step is where you can give your terrain different roughness/smoothness. </span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 466.00px; height: 75.00px;"><img alt="" src="images/image22.png" style="width: 466.00px; height: 75.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The TerrainGen is in charge of keeping track of the map, the floor (solid) tiles, and has the RNG built in. calling the constructor starts the random generation by invoking the _walk function.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span class="c10">&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 548.00px; height: 176.00px;"><img alt="" src="images/image23.png" style="width: 548.00px; height: 176.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><a id="id.uq3gaokhmg21"></a><h2 class="c5" id="h.i2qina4s9ibo"><span class="c12">Startup</span></h2><hr><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">So to initialize the game, a few things need to take place, we need to import the scripts we are using, to ensure they are loaded in the correct order, and we need to create a new instance of the TerrainGen class, this will create a new random terrain. This terrainGen instance needs to be global, and be accessible from anywhere in the project. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The Startup.js in the Scripts folder starts the whole process.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span class="c10">&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 507.00px; height: 138.00px;"><img alt="" src="images/image12.png" style="width: 507.00px; height: 138.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7 c8"><span class="c1"></span></p><p class="c6"><span class="c1">This script setups up a global object, that will be exposed to all the event sheets. Then during the runOnStartup function we load our external RNG library (chance.js) and the terrainGen class we created. We are not creating any instances of terrain at this point, because there is no layout currently loaded. The layout is loaded in at a later time. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Now all of the game logic is contained in one event sheet (eMain) </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 647.50px; height: 356.71px;"><img alt="" src="images/image3.png" style="width: 647.50px; height: 356.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Let&rsquo;s examine the javascript that gets executed on the start of the layout.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The first thing we do is create a new instance of TerrainGen and assign it to our global terrainGen variable defined in Startup.js</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 560.00px; height: 41.00px;"><img alt="" src="images/image10.png" style="width: 560.00px; height: 41.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The next thing we do render the tilemap, at this point terrainGen contains a 2D javascript array (called map) that contains our level data.in order to translate that to the TileMap object in the layout we need to call the render function</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.00px; height: 50.00px;"><img alt="" src="images/image30.png" style="width: 434.00px; height: 50.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">This render function takes in the runtime, and the name of C3 Function that will get called back.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">If we expand the Functions group we can find a function called updateTileMap that takes 3 parameters x, y, and value</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 97.33px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 97.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">This C3 function sets a specific tile on the tilemap that is currently in the layout. Let&rsquo;s examine the render function in the TerrainGen class</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 126.67px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 126.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">This is a nested loop that will traverse the 2D array that is holding our level data, then using the passed in runtime object we use callFunction to invoke the updateTilemap function on the event sheet, we pass in the x, y and value of that cell in the data structure. This will essential draw the map.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The next step after drawing the map is to figure out where the player and enemy tanks are going to be placed and then actually create them. </span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.00px; height: 63.00px;"><img alt="" src="images/image11.png" style="width: 434.00px; height: 63.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The pickRandomSpot uses chance js to pick a random cell on the floor. (In hindsight I should have made this smarter, there is a chance that both the enemy and player will spawn in very close proximity.)</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The Next step after picking the random starting location of the player and enemy. Is to create their instances. We first get a reference to their object class, then we use that objectClass to create a new instance of that object.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 102.67px;"><img alt="" src="images/image26.png" style="width: 624.00px; height: 102.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Since our tile map is 8x8 we need to transform our random cell position to its equivalent world position. To do this you just multiply the cell x/y by the width/height, </span></p><p class="c6"><span class="c1">which in this case is 8.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The next 2 steps were added to make the AI smart. At this time since we know the position of the player and the enemy we can calculate the distance between.this value is used later so the enemy tank has a chance of hitting you. </span></p><p class="c6"><span class="c1">We will discuss this in the next section.</span></p><a id="id.5iumakmjt8yx"></a><h2 class="c5" id="h.fh2pwx3zjroh"><span class="c12">Enemy AI</span></h2><hr><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">In order to make the enemy AI able to hit the player we need the distance between the two. We Gather this information in the start of the layout as soon as the player and enemy instances have been created.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">To get the distance we call a utility function which gives us the distance from the enemy to the player.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 366.00px; height: 74.00px;"><img alt="" src="images/image4.png" style="width: 366.00px; height: 74.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7 c8"><span class="c1"></span></p><p class="c6"><span class="c1">After we have this value, we need to communicate it with the event sheet. So we save it to global variable on the event sheet called DistanceToPlayer.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 50.67px;"><img alt="" src="images/image13.png" style="width: 624.00px; height: 50.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">So how does the AI actually work. </span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 711.50px; height: 130.66px;"><img alt="" src="images/image27.png" style="width: 711.50px; height: 130.66px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The 2 events above pretty much sum it up. Every 2 seconds the enemy tank will fire at the player. The first thing it does is try and tween the turret to the correct angle. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">So what is the correct angle, well we don&rsquo;t want the angle to be too exact if not the enemy will always win in 2 seconds, and we also have to take into account their relative positions to get the correct angle.</span></p><p class="c6"><span class="c1">There is a C3 Function we use to give us a good idea.</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 122.67px;"><img alt="" src="images/image29.png" style="width: 624.00px; height: 122.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">We always start Aiming up at a 45 degree angle from the floor. Then we randomize give it take by 30 degrees. This ensures the enemy is always firing up just in case he is in a trench. Depending on the players x position we change the way we are facing (in terms of angles) </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Construct has their angle system a bit inverted, so 90 degress is facing straight down, and straight up is 270 degrees. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">270 - 45 = 225</span></p><p class="c6"><span class="c1">270 + 45 = 315</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Then we just add a random number from -15 to +15 every single shot.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Now in order to determine the right amount of force we need to shoot the bullet, we make an educated guess based on the distance.</span></p><p class="c7"><span class="c10">&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 401.95px; height: 208.50px;"><img alt="" src="images/image18.png" style="width: 401.95px; height: 208.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Let&rsquo;s Analyze this expression.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span>clamp</span><span class="c9">(</span><span>ceil</span><span class="c9">(</span><span>DistanceToPlayer</span><span class="c9">/</span><span class="c3">75</span><span class="c9">) + </span><span>choose</span><span class="c9">(</span><span class="c3">0</span><span class="c9">, </span><span class="c3">1</span><span class="c9">, </span><span class="c3">2</span><span class="c9">), </span><span class="c3">1</span><span class="c9">&nbsp;,</span><span class="c3">8</span><span class="c9 c11">)</span></p><p class="c2"><span class="c9 c14"></span></p><p class="c6"><span class="c1">So let&rsquo;s break this down a bit</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">DistanceToPlayer/75 </span></p><p class="c6"><span class="c1">We take the distance to the player in pixels in divided by 75</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Why 75? Well the width of our layout is 640, to ensure any shot can get from one end of the map to the other we needed to have 8 different power levels. And after a lot of testing </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">640/75 = 8.5333333 (9 with the ciel)</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Which is pretty optimal since it covers the whole map plus a bit extra just in case. So really DistanceToPlayer/75 is telling us which power level to use to fire the shot to get really close to hitting the player. Now to add a bit of randomness and ease for the player we then give the enemy a chance to overshoot the player by a factor of 2.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c10">DistanceToPlayer/75 + </span><span class="c1 c13">Choose(0, 1 ,2)</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">We can be exact, off by power level of 1, or off by power level of 2. And just to make sure we clamp the power level to a value between 1 and 8. Each power level will travel about 75 pixels depending on the angle.</span></p><a id="id.8bc87fbtrk9h"></a><h2 class="c5" id="h.afmdjkmyx66x"><span class="c12">Terrain Deformation</span></h2><hr><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The next interesting concepts in this project is the TileMap Deformation when hit by a bullet. This is all handled in Bullet collision event with it collides with the Collision Tilemap.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">So pretty much there are 2 Tilemaps in the layout the one just used for drawing and the Tilemap used for collisions (which has a solid behavior)</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">On the C3 function to update the tilemap there are 2 subevents which handle updating the collision tilemap</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 264.00px;"><img alt="" src="images/image17.png" style="width: 624.00px; height: 264.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Since both tilemaps at the same width and height, the x and y values are the same when rendering.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">So this pretty much mean if we update our terrain data structure and call the render function, and new updates should be handled seamlessly. And that&rsquo;s pretty much what we do to deform the tilemap. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Let&rsquo;s take a look at the bullet collision Javascript code.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 689.50px; height: 322.25px;"><img alt="" src="images/image15.png" style="width: 689.50px; height: 322.25px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The first thing we do is get the BulletObject class, using this class since we are inside an event we can get the instance of that object that were picked (The Bullet) by construct using getFirstPickedInstance()</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Now that we have a reference to the instance. We need to grab our GroundExplosion Object Class (our particle effect). </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">When we were creating our player and enemy we needed to translate the cell values to the layout position. Now we have to do something similar but backwards. We need to that bullets layout position and convert it to it&#39;s Cell X and Y value. We do that by dividing the Bullets x/y value by 8 and making sure we Floor that value to get back an integer.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 422.00px; height: 60.00px;"><img alt="" src="images/image1.png" style="width: 422.00px; height: 60.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">Now we call a function on the TerrianGen class which takes and X and a Y position</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 524.00px; height: 56.00px;"><img alt="" src="images/image21.png" style="width: 524.00px; height: 56.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7 c8"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">So the calculateTileCollision function is pretty simple when we dig into it.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 474.50px; height: 403.44px;"><img alt="" src="images/image16.png" style="width: 474.50px; height: 403.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">How this works is we get every cell around the passed in x,y values. Always set them to 0. Meaning we erase that cell if its solid. This will always create a 3x3 area of cells that will be destroyed by the blast, relative to the starting x,y cell (in the middle).</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Then to spice things up we try and erase another layer around our crater, but this time there is a 50% chance for each cell to not be erased, this will cause unique crater patterns.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">The way this works is we pass our setCell function as a callback of our randomize function and all our randomize function does is take a likelihood and function will get called and the function to call as a parameter and uses chance js to determine if the callback gets executed.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 288.50px; height: 84.76px;"><img alt="" src="images/image25.png" style="width: 288.50px; height: 84.76px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c1">&nbsp;</span></p><p class="c7 c8"><span class="c1"></span></p><p class="c6"><span class="c1">So after this call the 2D array in TerrainGen class will be a bit different where the bullet struck. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">In hindsight this could of been optimized by only updating the cells that changed, but i just called the updateTilemap function one more time which renders the whole map again.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">But before we actually call render, we need to spawn the particles (can&rsquo;t forget about that juice) &amp; we need to destroy the bullet.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 89.33px;"><img alt="" src="images/image19.png" style="width: 624.00px; height: 89.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">After that then we re render the tilemap.</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 453.00px; height: 47.00px;"><img alt="" src="images/image28.png" style="width: 453.00px; height: 47.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7 c8"><span class="c1"></span></p><p class="c6"><span class="c1">And also you can&rsquo;t forget about the screen shake</span></p><p class="c2"><span class="c1"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 579.00px; height: 78.00px;"><img alt="" src="images/image8.png" style="width: 579.00px; height: 78.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><a id="id.dtb1ml45pyfp"></a><h2 class="c5" id="h.kxubo0avntzc"><span class="c12">End</span></h2><hr><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">So this is pretty much the first of these development logs I plan to release. I want to start doing this monthly, where I create a game (probably not big in scope) and dissect its implementation. If you guys have any ideas or suggestions for any types of games or system you want to see implemented, Let me know and I will try and prioritize them. </span></p><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c1">Also shameless plugs:</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c10">If your into Construct 3 Plugin development Check out this open source plugin IDE I created called </span><span class="c0"><a class="c4" href="https://www.google.com/url?q=https://piranha305.itch.io/c3ide&amp;sa=D&amp;ust=1564436451819000">C3IDE</a></span><span class="c1">. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c10">If your interested in the C# source code, you can find that on </span><span class="c0"><a class="c4" href="https://www.google.com/url?q=https://github.com/armandoalonso/c3IDE&amp;sa=D&amp;ust=1564436451819000">GitHub</a></span><span class="c1">. </span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c10">Also follow me on : </span><span class="c0"><a class="c4" href="https://www.google.com/url?q=https://twitter.com/piranha_305&amp;sa=D&amp;ust=1564436451819000">Twitter</a></span><span class="c1">&nbsp;Where i will post updates and new project and stuff like that.</span></p><p class="c2"><span class="c1"></span></p><p class="c6"><span class="c10">Thanks!</span></p><p class="c2"><span class="c1"></span></p></body></html>